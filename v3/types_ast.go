// Code generated by goadlc v3 - DO NOT EDIT.
package goadl

import (
	"github.com/adl-lang/goadl_rt/v3/customtypes"
	"github.com/adl-lang/goadl_rt/v3/sys/adlast"
	. "github.com/adl-lang/goadl_rt/v3/sys/types"
)

func Texpr_Either[T1 any, T2 any](t1 ATypeExpr[T1], t2 ATypeExpr[T2]) ATypeExpr[Either[T1, T2]] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("sys.types", "Either"),
		),
		[]adlast.TypeExpr{t1.Value, t2.Value},
	)
	return ATypeExpr[Either[T1, T2]]{
		Value: te,
	}
}

func AST_Either() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"Either",
		Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_union_(
			adlast.MakeAll_Union(
				[]adlast.Ident{
					"T1",
					"T2",
				},
				[]adlast.Field{
					adlast.MakeAll_Field(
						"left",
						"left",
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_typeParam(
								"T1",
							),
							[]adlast.TypeExpr{},
						),
						Make_Maybe_nothing[any](),
						customtypes.MapMap[adlast.ScopedName, any]{},
					),
					adlast.MakeAll_Field(
						"right",
						"right",
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_typeParam(
								"T2",
							),
							[]adlast.TypeExpr{},
						),
						Make_Maybe_nothing[any](),
						customtypes.MapMap[adlast.ScopedName, any]{},
					),
				},
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{},
	)
	return adlast.Make_ScopedDecl("sys.types", decl)
}

func init() {
	RESOLVER.Register(
		adlast.Make_ScopedName("sys.types", "Either"),
		AST_Either(),
	)
}

func Texpr_Map[K comparable, V any](k ATypeExpr[K], v ATypeExpr[V]) ATypeExpr[customtypes.MapMap[K, V]] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("sys.types", "Map"),
		),
		[]adlast.TypeExpr{k.Value, v.Value},
	)
	return ATypeExpr[customtypes.MapMap[K, V]]{
		Value: te,
	}
}

func AST_Map() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"Map",
		Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_newtype_(
			adlast.MakeAll_NewType(
				[]adlast.Ident{
					"K",
					"V",
				},
				adlast.MakeAll_TypeExpr(
					adlast.Make_TypeRef_primitive(
						"Vector",
					),
					[]adlast.TypeExpr{
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_reference(
								adlast.MakeAll_ScopedName(
									"sys.types",
									"MapEntry",
								),
							),
							[]adlast.TypeExpr{
								adlast.MakeAll_TypeExpr(
									adlast.Make_TypeRef_typeParam(
										"K",
									),
									[]adlast.TypeExpr{},
								),
								adlast.MakeAll_TypeExpr(
									adlast.Make_TypeRef_typeParam(
										"V",
									),
									[]adlast.TypeExpr{},
								),
							},
						),
					},
				),
				Make_Maybe_nothing[any](),
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{adlast.Make_ScopedName("adlc.config.go_", "GoCustomType"): map[string]interface{}{"gotype": map[string]interface{}{"import_path": "github.com/adl-lang/goadl_rt/v3/customtypes", "name": "MapMap", "pkg": "customtypes", "type_constraints": []interface{}{"comparable", "any"}}, "helpers": map[string]interface{}{"import_path": "github.com/adl-lang/goadl_rt/v3/customtypes", "name": "MapHelper", "pkg": "customtypes"}}},
	)
	return adlast.Make_ScopedDecl("sys.types", decl)
}

func init() {
	RESOLVER.Register(
		adlast.Make_ScopedName("sys.types", "Map"),
		AST_Map(),
	)
	RESOLVER.RegisterHelper(
		adlast.Make_ScopedName("sys.types", "Map"),
		(*customtypes.MapHelper)(nil),
	)
}

func Texpr_MapEntry[K any, V any](k ATypeExpr[K], v ATypeExpr[V]) ATypeExpr[MapEntry[K, V]] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("sys.types", "MapEntry"),
		),
		[]adlast.TypeExpr{k.Value, v.Value},
	)
	return ATypeExpr[MapEntry[K, V]]{
		Value: te,
	}
}

func AST_MapEntry() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"MapEntry",
		Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_struct_(
			adlast.MakeAll_Struct(
				[]adlast.Ident{
					"K",
					"V",
				},
				[]adlast.Field{
					adlast.MakeAll_Field(
						"key",
						"k",
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_typeParam(
								"K",
							),
							[]adlast.TypeExpr{},
						),
						Make_Maybe_nothing[any](),
						customtypes.MapMap[adlast.ScopedName, any]{},
					),
					adlast.MakeAll_Field(
						"value",
						"v",
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_typeParam(
								"V",
							),
							[]adlast.TypeExpr{},
						),
						Make_Maybe_nothing[any](),
						customtypes.MapMap[adlast.ScopedName, any]{},
					),
				},
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{},
	)
	return adlast.Make_ScopedDecl("sys.types", decl)
}

func init() {
	RESOLVER.Register(
		adlast.Make_ScopedName("sys.types", "MapEntry"),
		AST_MapEntry(),
	)
}

func Texpr_Maybe[T any](t ATypeExpr[T]) ATypeExpr[Maybe[T]] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("sys.types", "Maybe"),
		),
		[]adlast.TypeExpr{t.Value},
	)
	return ATypeExpr[Maybe[T]]{
		Value: te,
	}
}

func AST_Maybe() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"Maybe",
		Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_union_(
			adlast.MakeAll_Union(
				[]adlast.Ident{
					"T",
				},
				[]adlast.Field{
					adlast.MakeAll_Field(
						"nothing",
						"nothing",
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_primitive(
								"Void",
							),
							[]adlast.TypeExpr{},
						),
						Make_Maybe_nothing[any](),
						customtypes.MapMap[adlast.ScopedName, any]{},
					),
					adlast.MakeAll_Field(
						"just",
						"just",
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_typeParam(
								"T",
							),
							[]adlast.TypeExpr{},
						),
						Make_Maybe_nothing[any](),
						customtypes.MapMap[adlast.ScopedName, any]{},
					),
				},
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{},
	)
	return adlast.Make_ScopedDecl("sys.types", decl)
}

func init() {
	RESOLVER.Register(
		adlast.Make_ScopedName("sys.types", "Maybe"),
		AST_Maybe(),
	)
}

func Texpr_Pair[T1 any, T2 any](t1 ATypeExpr[T1], t2 ATypeExpr[T2]) ATypeExpr[Pair[T1, T2]] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("sys.types", "Pair"),
		),
		[]adlast.TypeExpr{t1.Value, t2.Value},
	)
	return ATypeExpr[Pair[T1, T2]]{
		Value: te,
	}
}

func AST_Pair() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"Pair",
		Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_struct_(
			adlast.MakeAll_Struct(
				[]adlast.Ident{
					"T1",
					"T2",
				},
				[]adlast.Field{
					adlast.MakeAll_Field(
						"v1",
						"v1",
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_typeParam(
								"T1",
							),
							[]adlast.TypeExpr{},
						),
						Make_Maybe_nothing[any](),
						customtypes.MapMap[adlast.ScopedName, any]{},
					),
					adlast.MakeAll_Field(
						"v2",
						"v2",
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_typeParam(
								"T2",
							),
							[]adlast.TypeExpr{},
						),
						Make_Maybe_nothing[any](),
						customtypes.MapMap[adlast.ScopedName, any]{},
					),
				},
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{},
	)
	return adlast.Make_ScopedDecl("sys.types", decl)
}

func init() {
	RESOLVER.Register(
		adlast.Make_ScopedName("sys.types", "Pair"),
		AST_Pair(),
	)
}

func Texpr_Result[T any, E any](t ATypeExpr[T], e ATypeExpr[E]) ATypeExpr[Result[T, E]] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("sys.types", "Result"),
		),
		[]adlast.TypeExpr{t.Value, e.Value},
	)
	return ATypeExpr[Result[T, E]]{
		Value: te,
	}
}

func AST_Result() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"Result",
		Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_union_(
			adlast.MakeAll_Union(
				[]adlast.Ident{
					"T",
					"E",
				},
				[]adlast.Field{
					adlast.MakeAll_Field(
						"ok",
						"ok",
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_typeParam(
								"T",
							),
							[]adlast.TypeExpr{},
						),
						Make_Maybe_nothing[any](),
						customtypes.MapMap[adlast.ScopedName, any]{},
					),
					adlast.MakeAll_Field(
						"error",
						"error",
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_typeParam(
								"E",
							),
							[]adlast.TypeExpr{},
						),
						Make_Maybe_nothing[any](),
						customtypes.MapMap[adlast.ScopedName, any]{},
					),
				},
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{},
	)
	return adlast.Make_ScopedDecl("sys.types", decl)
}

func init() {
	RESOLVER.Register(
		adlast.Make_ScopedName("sys.types", "Result"),
		AST_Result(),
	)
}

func Texpr_Set[T comparable](t ATypeExpr[T]) ATypeExpr[customtypes.MapSet[T]] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("sys.types", "Set"),
		),
		[]adlast.TypeExpr{t.Value},
	)
	return ATypeExpr[customtypes.MapSet[T]]{
		Value: te,
	}
}

func AST_Set() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"Set",
		Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_newtype_(
			adlast.MakeAll_NewType(
				[]adlast.Ident{
					"T",
				},
				adlast.MakeAll_TypeExpr(
					adlast.Make_TypeRef_primitive(
						"Vector",
					),
					[]adlast.TypeExpr{
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_typeParam(
								"T",
							),
							[]adlast.TypeExpr{},
						),
					},
				),
				Make_Maybe_nothing[any](),
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{adlast.Make_ScopedName("adlc.config.go_", "GoCustomType"): map[string]interface{}{"gotype": map[string]interface{}{"import_path": "github.com/adl-lang/goadl_rt/v3/customtypes", "name": "MapSet", "pkg": "customtypes", "type_constraints": []interface{}{"comparable"}}, "helpers": map[string]interface{}{"import_path": "github.com/adl-lang/goadl_rt/v3/customtypes", "name": "SetHelper", "pkg": "customtypes"}}},
	)
	return adlast.Make_ScopedDecl("sys.types", decl)
}

func init() {
	RESOLVER.Register(
		adlast.Make_ScopedName("sys.types", "Set"),
		AST_Set(),
	)
	RESOLVER.RegisterHelper(
		adlast.Make_ScopedName("sys.types", "Set"),
		(*customtypes.SetHelper)(nil),
	)
}
