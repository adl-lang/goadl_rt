// Code generated by goadlc v3 - DO NOT EDIT.
package types

import (
	"fmt"
)

type Either[T1 any, T2 any] struct {
	Branch EitherBranch[T1, T2]
}

type EitherBranch[T1 any, T2 any] interface {
	isEitherBranch()
}

func (*Either[T1, T2]) MakeNewBranch(key string) (any, error) {
	switch key {
	case "left":
		return &_Either_Left[T1]{}, nil
	case "right":
		return &_Either_Right[T2]{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _Either_Left[T1 any] struct {
	V T1 `branch:"left"`
}
type _Either_Right[T2 any] struct {
	V T2 `branch:"right"`
}

func (_Either_Left[T1]) isEitherBranch()  {}
func (_Either_Right[T2]) isEitherBranch() {}

func Make_Either_left[T1 any, T2 any](v T1) Either[T1, T2] {
	return Either[T1, T2]{
		_Either_Left[T1]{v},
	}
}

func Make_Either_right[T1 any, T2 any](v T2) Either[T1, T2] {
	return Either[T1, T2]{
		_Either_Right[T2]{v},
	}
}

func (un Either[T1, T2]) Cast_left() (T1, bool) {
	br, ok := un.Branch.(_Either_Left[T1])
	return br.V, ok
}

func (un Either[T1, T2]) Cast_right() (T2, bool) {
	br, ok := un.Branch.(_Either_Right[T2])
	return br.V, ok
}

func Handle_Either[T1 any, T2 any, T any](
	_in Either[T1, T2],
	left func(left T1) T,
	right func(right T2) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _Either_Left[T1]:
		if left != nil {
			return left(_b.V)
		}
	case _Either_Right[T2]:
		if right != nil {
			return right(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Either")
}

func HandleWithErr_Either[T1 any, T2 any, T any](
	_in Either[T1, T2],
	left func(left T1) (T, error),
	right func(right T2) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _Either_Left[T1]:
		if left != nil {
			return left(_b.V)
		}
	case _Either_Right[T2]:
		if right != nil {
			return right(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Either")
}

type MapEntry[K any, V any] struct {
	Key   K `json:"k"`
	Value V `json:"v"`
}

func MakeAll_MapEntry[K any, V any](
	key K,
	value V,
) MapEntry[K, V] {
	return MapEntry[K, V]{
		Key:   key,
		Value: value,
	}
}

func Make_MapEntry[K any, V any](
	key K,
	value V,
) MapEntry[K, V] {
	ret := MapEntry[K, V]{
		Key:   key,
		Value: value,
	}
	return ret
}

type Maybe[T any] struct {
	Branch MaybeBranch[T]
}

type MaybeBranch[T any] interface {
	isMaybeBranch()
}

func (*Maybe[T]) MakeNewBranch(key string) (any, error) {
	switch key {
	case "nothing":
		return &_Maybe_Nothing{}, nil
	case "just":
		return &_Maybe_Just[T]{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _Maybe_Nothing struct {
	V struct{} `branch:"nothing"`
}
type _Maybe_Just[T any] struct {
	V T `branch:"just"`
}

func (_Maybe_Nothing) isMaybeBranch() {}
func (_Maybe_Just[T]) isMaybeBranch() {}

func Make_Maybe_nothing[T any]() Maybe[T] {
	return Maybe[T]{
		_Maybe_Nothing{struct{}{}},
	}
}

func Make_Maybe_just[T any](v T) Maybe[T] {
	return Maybe[T]{
		_Maybe_Just[T]{v},
	}
}

func (un Maybe[T]) Cast_nothing() (struct{}, bool) {
	br, ok := un.Branch.(_Maybe_Nothing)
	return br.V, ok
}

func (un Maybe[T]) Cast_just() (T, bool) {
	br, ok := un.Branch.(_Maybe_Just[T])
	return br.V, ok
}

func Handle_Maybe[T any, T2 any](
	_in Maybe[T],
	nothing func(nothing struct{}) T2,
	just func(just T) T2,
	_default func() T2,
) T2 {
	switch _b := _in.Branch.(type) {
	case _Maybe_Nothing:
		if nothing != nil {
			return nothing(_b.V)
		}
	case _Maybe_Just[T]:
		if just != nil {
			return just(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Maybe")
}

func HandleWithErr_Maybe[T any, T2 any](
	_in Maybe[T],
	nothing func(nothing struct{}) (T2, error),
	just func(just T) (T2, error),
	_default func() (T2, error),
) (T2, error) {
	switch _b := _in.Branch.(type) {
	case _Maybe_Nothing:
		if nothing != nil {
			return nothing(_b.V)
		}
	case _Maybe_Just[T]:
		if just != nil {
			return just(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Maybe")
}

type Pair[T1 any, T2 any] struct {
	V1 T1 `json:"v1"`
	V2 T2 `json:"v2"`
}

func MakeAll_Pair[T1 any, T2 any](
	v1 T1,
	v2 T2,
) Pair[T1, T2] {
	return Pair[T1, T2]{
		V1: v1,
		V2: v2,
	}
}

func Make_Pair[T1 any, T2 any](
	v1 T1,
	v2 T2,
) Pair[T1, T2] {
	ret := Pair[T1, T2]{
		V1: v1,
		V2: v2,
	}
	return ret
}

type Result[T any, E any] struct {
	Branch ResultBranch[T, E]
}

type ResultBranch[T any, E any] interface {
	isResultBranch()
}

func (*Result[T, E]) MakeNewBranch(key string) (any, error) {
	switch key {
	case "ok":
		return &_Result_Ok[T]{}, nil
	case "error":
		return &_Result_Error[E]{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _Result_Ok[T any] struct {
	V T `branch:"ok"`
}
type _Result_Error[E any] struct {
	V E `branch:"error"`
}

func (_Result_Ok[T]) isResultBranch()    {}
func (_Result_Error[E]) isResultBranch() {}

func Make_Result_ok[T any, E any](v T) Result[T, E] {
	return Result[T, E]{
		_Result_Ok[T]{v},
	}
}

func Make_Result_error[T any, E any](v E) Result[T, E] {
	return Result[T, E]{
		_Result_Error[E]{v},
	}
}

func (un Result[T, E]) Cast_ok() (T, bool) {
	br, ok := un.Branch.(_Result_Ok[T])
	return br.V, ok
}

func (un Result[T, E]) Cast_error() (E, bool) {
	br, ok := un.Branch.(_Result_Error[E])
	return br.V, ok
}

func Handle_Result[T any, E any, T2 any](
	_in Result[T, E],
	ok func(ok T) T2,
	error func(error E) T2,
	_default func() T2,
) T2 {
	switch _b := _in.Branch.(type) {
	case _Result_Ok[T]:
		if ok != nil {
			return ok(_b.V)
		}
	case _Result_Error[E]:
		if error != nil {
			return error(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Result")
}

func HandleWithErr_Result[T any, E any, T2 any](
	_in Result[T, E],
	ok func(ok T) (T2, error),
	error func(error E) (T2, error),
	_default func() (T2, error),
) (T2, error) {
	switch _b := _in.Branch.(type) {
	case _Result_Ok[T]:
		if ok != nil {
			return ok(_b.V)
		}
	case _Result_Error[E]:
		if error != nil {
			return error(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Result")
}
