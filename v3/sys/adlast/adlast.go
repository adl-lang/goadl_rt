// Code generated by goadlc v3 - DO NOT EDIT.
package adlast

import (
	"fmt"
	"github.com/adl-lang/goadl_rt/v3/customtypes"
	"github.com/adl-lang/goadl_rt/v3/sys/types"
)

// type ATypeExpr[T any] struct {
// 	_ATypeExpr[T]
// }

// type _ATypeExpr[T any] struct {
// 	Value TypeExpr `json:"value"`
// }

// func MakeAll_ATypeExpr[T any](
// 	value TypeExpr,
// ) ATypeExpr[T] {
// 	return ATypeExpr[T]{
// 		_ATypeExpr[T]{
// 			Value: value,
// 		},
// 	}
// }

// func Make_ATypeExpr[T any](
// 	value TypeExpr,
// ) ATypeExpr[T] {
// 	ret := ATypeExpr[T]{
// 		_ATypeExpr[T]{
// 			Value: value,
// 		},
// 	}
// 	return ret
// }

type Annotations = customtypes.MapMap[ScopedName, any]

type Decl struct {
	_Decl
}

type _Decl struct {
	Name        Ident               `json:"name"`
	Version     types.Maybe[uint32] `json:"version"`
	Type_       DeclType            `json:"type_"`
	Annotations Annotations         `json:"annotations"`
}

func MakeAll_Decl(
	name Ident,
	version types.Maybe[uint32],
	type_ DeclType,
	annotations Annotations,
) Decl {
	return Decl{
		_Decl{
			Name:        name,
			Version:     version,
			Type_:       type_,
			Annotations: annotations,
		},
	}
}

func Make_Decl(
	name Ident,
	version types.Maybe[uint32],
	type_ DeclType,
	annotations Annotations,
) Decl {
	ret := Decl{
		_Decl{
			Name:        name,
			Version:     version,
			Type_:       type_,
			Annotations: annotations,
		},
	}
	return ret
}

type DeclType struct {
	Branch DeclTypeBranch
}

type DeclTypeBranch interface {
	isDeclTypeBranch()
}

func (*DeclType) MakeNewBranch(key string) (any, error) {
	switch key {
	case "struct_":
		return &_DeclType_Struct_{}, nil
	case "union_":
		return &_DeclType_Union_{}, nil
	case "type_":
		return &_DeclType_Type_{}, nil
	case "newtype_":
		return &_DeclType_Newtype_{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _DeclType_Struct_ struct {
	V Struct `branch:"struct_"`
}
type _DeclType_Union_ struct {
	V Union `branch:"union_"`
}
type _DeclType_Type_ struct {
	V TypeDef `branch:"type_"`
}
type _DeclType_Newtype_ struct {
	V NewType `branch:"newtype_"`
}

func (_DeclType_Struct_) isDeclTypeBranch()  {}
func (_DeclType_Union_) isDeclTypeBranch()   {}
func (_DeclType_Type_) isDeclTypeBranch()    {}
func (_DeclType_Newtype_) isDeclTypeBranch() {}

func Make_DeclType_struct_(v Struct) DeclType {
	return DeclType{
		_DeclType_Struct_{v},
	}
}

func Make_DeclType_union_(v Union) DeclType {
	return DeclType{
		_DeclType_Union_{v},
	}
}

func Make_DeclType_type_(v TypeDef) DeclType {
	return DeclType{
		_DeclType_Type_{v},
	}
}

func Make_DeclType_newtype_(v NewType) DeclType {
	return DeclType{
		_DeclType_Newtype_{v},
	}
}

func (un DeclType) Cast_struct_() (Struct, bool) {
	br, ok := un.Branch.(_DeclType_Struct_)
	return br.V, ok
}

func (un DeclType) Cast_union_() (Union, bool) {
	br, ok := un.Branch.(_DeclType_Union_)
	return br.V, ok
}

func (un DeclType) Cast_type_() (TypeDef, bool) {
	br, ok := un.Branch.(_DeclType_Type_)
	return br.V, ok
}

func (un DeclType) Cast_newtype_() (NewType, bool) {
	br, ok := un.Branch.(_DeclType_Newtype_)
	return br.V, ok
}

func Handle_DeclType[T any](
	_in DeclType,
	struct_ func(struct_ Struct) T,
	union_ func(union_ Union) T,
	type_ func(type_ TypeDef) T,
	newtype_ func(newtype_ NewType) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _DeclType_Struct_:
		if struct_ != nil {
			return struct_(_b.V)
		}
	case _DeclType_Union_:
		if union_ != nil {
			return union_(_b.V)
		}
	case _DeclType_Type_:
		if type_ != nil {
			return type_(_b.V)
		}
	case _DeclType_Newtype_:
		if newtype_ != nil {
			return newtype_(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : DeclType")
}

func HandleWithErr_DeclType[T any](
	_in DeclType,
	struct_ func(struct_ Struct) (T, error),
	union_ func(union_ Union) (T, error),
	type_ func(type_ TypeDef) (T, error),
	newtype_ func(newtype_ NewType) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _DeclType_Struct_:
		if struct_ != nil {
			return struct_(_b.V)
		}
	case _DeclType_Union_:
		if union_ != nil {
			return union_(_b.V)
		}
	case _DeclType_Type_:
		if type_ != nil {
			return type_(_b.V)
		}
	case _DeclType_Newtype_:
		if newtype_ != nil {
			return newtype_(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : DeclType")
}

type DeclVersions = []Decl

type Field struct {
	_Field
}

type _Field struct {
	Name           Ident            `json:"name"`
	SerializedName Ident            `json:"serializedName"`
	TypeExpr       TypeExpr         `json:"typeExpr"`
	Default        types.Maybe[any] `json:"default"`
	Annotations    Annotations      `json:"annotations"`
}

func MakeAll_Field(
	name Ident,
	serializedname Ident,
	typeexpr TypeExpr,
	default_ types.Maybe[any],
	annotations Annotations,
) Field {
	return Field{
		_Field{
			Name:           name,
			SerializedName: serializedname,
			TypeExpr:       typeexpr,
			Default:        default_,
			Annotations:    annotations,
		},
	}
}

func Make_Field(
	name Ident,
	serializedname Ident,
	typeexpr TypeExpr,
	default_ types.Maybe[any],
	annotations Annotations,
) Field {
	ret := Field{
		_Field{
			Name:           name,
			SerializedName: serializedname,
			TypeExpr:       typeexpr,
			Default:        default_,
			Annotations:    annotations,
		},
	}
	return ret
}

type Ident = string

type Import struct {
	Branch ImportBranch
}

type ImportBranch interface {
	isImportBranch()
}

func (*Import) MakeNewBranch(key string) (any, error) {
	switch key {
	case "moduleName":
		return &_Import_ModuleName{}, nil
	case "scopedName":
		return &_Import_ScopedName{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _Import_ModuleName struct {
	V ModuleName `branch:"moduleName"`
}
type _Import_ScopedName struct {
	V ScopedName `branch:"scopedName"`
}

func (_Import_ModuleName) isImportBranch() {}
func (_Import_ScopedName) isImportBranch() {}

func Make_Import_moduleName(v ModuleName) Import {
	return Import{
		_Import_ModuleName{v},
	}
}

func Make_Import_scopedName(v ScopedName) Import {
	return Import{
		_Import_ScopedName{v},
	}
}

func (un Import) Cast_moduleName() (ModuleName, bool) {
	br, ok := un.Branch.(_Import_ModuleName)
	return br.V, ok
}

func (un Import) Cast_scopedName() (ScopedName, bool) {
	br, ok := un.Branch.(_Import_ScopedName)
	return br.V, ok
}

func Handle_Import[T any](
	_in Import,
	moduleName func(moduleName ModuleName) T,
	scopedName func(scopedName ScopedName) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _Import_ModuleName:
		if moduleName != nil {
			return moduleName(_b.V)
		}
	case _Import_ScopedName:
		if scopedName != nil {
			return scopedName(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Import")
}

func HandleWithErr_Import[T any](
	_in Import,
	moduleName func(moduleName ModuleName) (T, error),
	scopedName func(scopedName ScopedName) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _Import_ModuleName:
		if moduleName != nil {
			return moduleName(_b.V)
		}
	case _Import_ScopedName:
		if scopedName != nil {
			return scopedName(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Import")
}

type Module struct {
	_Module
}

type _Module struct {
	Name        ModuleName      `json:"name"`
	Imports     []Import        `json:"imports"`
	Decls       map[string]Decl `json:"decls"`
	Annotations Annotations     `json:"annotations"`
}

func MakeAll_Module(
	name ModuleName,
	imports []Import,
	decls map[string]Decl,
	annotations Annotations,
) Module {
	return Module{
		_Module{
			Name:        name,
			Imports:     imports,
			Decls:       decls,
			Annotations: annotations,
		},
	}
}

func Make_Module(
	name ModuleName,
	imports []Import,
	decls map[string]Decl,
	annotations Annotations,
) Module {
	ret := Module{
		_Module{
			Name:        name,
			Imports:     imports,
			Decls:       decls,
			Annotations: annotations,
		},
	}
	return ret
}

type ModuleName = string

type NewType struct {
	_NewType
}

type _NewType struct {
	TypeParams []Ident          `json:"typeParams"`
	TypeExpr   TypeExpr         `json:"typeExpr"`
	Default    types.Maybe[any] `json:"default"`
}

func MakeAll_NewType(
	typeparams []Ident,
	typeexpr TypeExpr,
	default_ types.Maybe[any],
) NewType {
	return NewType{
		_NewType{
			TypeParams: typeparams,
			TypeExpr:   typeexpr,
			Default:    default_,
		},
	}
}

func Make_NewType(
	typeparams []Ident,
	typeexpr TypeExpr,
	default_ types.Maybe[any],
) NewType {
	ret := NewType{
		_NewType{
			TypeParams: typeparams,
			TypeExpr:   typeexpr,
			Default:    default_,
		},
	}
	return ret
}

type ScopedDecl struct {
	_ScopedDecl
}

type _ScopedDecl struct {
	ModuleName ModuleName `json:"moduleName"`
	Decl       Decl       `json:"decl"`
}

func MakeAll_ScopedDecl(
	modulename ModuleName,
	decl Decl,
) ScopedDecl {
	return ScopedDecl{
		_ScopedDecl{
			ModuleName: modulename,
			Decl:       decl,
		},
	}
}

func Make_ScopedDecl(
	modulename ModuleName,
	decl Decl,
) ScopedDecl {
	ret := ScopedDecl{
		_ScopedDecl{
			ModuleName: modulename,
			Decl:       decl,
		},
	}
	return ret
}

type ScopedName struct {
	_ScopedName
}

type _ScopedName struct {
	ModuleName ModuleName `json:"moduleName"`
	Name       Ident      `json:"name"`
}

func MakeAll_ScopedName(
	modulename ModuleName,
	name Ident,
) ScopedName {
	return ScopedName{
		_ScopedName{
			ModuleName: modulename,
			Name:       name,
		},
	}
}

func Make_ScopedName(
	modulename ModuleName,
	name Ident,
) ScopedName {
	ret := ScopedName{
		_ScopedName{
			ModuleName: modulename,
			Name:       name,
		},
	}
	return ret
}

type Struct struct {
	_Struct
}

type _Struct struct {
	TypeParams []Ident `json:"typeParams"`
	Fields     []Field `json:"fields"`
}

func MakeAll_Struct(
	typeparams []Ident,
	fields []Field,
) Struct {
	return Struct{
		_Struct{
			TypeParams: typeparams,
			Fields:     fields,
		},
	}
}

func Make_Struct(
	typeparams []Ident,
	fields []Field,
) Struct {
	ret := Struct{
		_Struct{
			TypeParams: typeparams,
			Fields:     fields,
		},
	}
	return ret
}

type TypeDef struct {
	_TypeDef
}

type _TypeDef struct {
	TypeParams []Ident  `json:"typeParams"`
	TypeExpr   TypeExpr `json:"typeExpr"`
}

func MakeAll_TypeDef(
	typeparams []Ident,
	typeexpr TypeExpr,
) TypeDef {
	return TypeDef{
		_TypeDef{
			TypeParams: typeparams,
			TypeExpr:   typeexpr,
		},
	}
}

func Make_TypeDef(
	typeparams []Ident,
	typeexpr TypeExpr,
) TypeDef {
	ret := TypeDef{
		_TypeDef{
			TypeParams: typeparams,
			TypeExpr:   typeexpr,
		},
	}
	return ret
}

type TypeExpr struct {
	_TypeExpr
}

type _TypeExpr struct {
	TypeRef    TypeRef    `json:"typeRef"`
	Parameters []TypeExpr `json:"parameters"`
}

func MakeAll_TypeExpr(
	typeref TypeRef,
	parameters []TypeExpr,
) TypeExpr {
	return TypeExpr{
		_TypeExpr{
			TypeRef:    typeref,
			Parameters: parameters,
		},
	}
}

func Make_TypeExpr(
	typeref TypeRef,
	parameters []TypeExpr,
) TypeExpr {
	ret := TypeExpr{
		_TypeExpr{
			TypeRef:    typeref,
			Parameters: parameters,
		},
	}
	return ret
}

type TypeRef struct {
	Branch TypeRefBranch
}

type TypeRefBranch interface {
	isTypeRefBranch()
}

func (*TypeRef) MakeNewBranch(key string) (any, error) {
	switch key {
	case "primitive":
		return &_TypeRef_Primitive{}, nil
	case "typeParam":
		return &_TypeRef_TypeParam{}, nil
	case "reference":
		return &_TypeRef_Reference{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _TypeRef_Primitive struct {
	V Ident `branch:"primitive"`
}
type _TypeRef_TypeParam struct {
	V Ident `branch:"typeParam"`
}
type _TypeRef_Reference struct {
	V ScopedName `branch:"reference"`
}

func (_TypeRef_Primitive) isTypeRefBranch() {}
func (_TypeRef_TypeParam) isTypeRefBranch() {}
func (_TypeRef_Reference) isTypeRefBranch() {}

func Make_TypeRef_primitive(v Ident) TypeRef {
	return TypeRef{
		_TypeRef_Primitive{v},
	}
}

func Make_TypeRef_typeParam(v Ident) TypeRef {
	return TypeRef{
		_TypeRef_TypeParam{v},
	}
}

func Make_TypeRef_reference(v ScopedName) TypeRef {
	return TypeRef{
		_TypeRef_Reference{v},
	}
}

func (un TypeRef) Cast_primitive() (Ident, bool) {
	br, ok := un.Branch.(_TypeRef_Primitive)
	return br.V, ok
}

func (un TypeRef) Cast_typeParam() (Ident, bool) {
	br, ok := un.Branch.(_TypeRef_TypeParam)
	return br.V, ok
}

func (un TypeRef) Cast_reference() (ScopedName, bool) {
	br, ok := un.Branch.(_TypeRef_Reference)
	return br.V, ok
}

func Handle_TypeRef[T any](
	_in TypeRef,
	primitive func(primitive Ident) T,
	typeParam func(typeParam Ident) T,
	reference func(reference ScopedName) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _TypeRef_Primitive:
		if primitive != nil {
			return primitive(_b.V)
		}
	case _TypeRef_TypeParam:
		if typeParam != nil {
			return typeParam(_b.V)
		}
	case _TypeRef_Reference:
		if reference != nil {
			return reference(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : TypeRef")
}

func HandleWithErr_TypeRef[T any](
	_in TypeRef,
	primitive func(primitive Ident) (T, error),
	typeParam func(typeParam Ident) (T, error),
	reference func(reference ScopedName) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _TypeRef_Primitive:
		if primitive != nil {
			return primitive(_b.V)
		}
	case _TypeRef_TypeParam:
		if typeParam != nil {
			return typeParam(_b.V)
		}
	case _TypeRef_Reference:
		if reference != nil {
			return reference(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : TypeRef")
}

type Union struct {
	_Union
}

type _Union struct {
	TypeParams []Ident `json:"typeParams"`
	Fields     []Field `json:"fields"`
}

func MakeAll_Union(
	typeparams []Ident,
	fields []Field,
) Union {
	return Union{
		_Union{
			TypeParams: typeparams,
			Fields:     fields,
		},
	}
}

func Make_Union(
	typeparams []Ident,
	fields []Field,
) Union {
	ret := Union{
		_Union{
			TypeParams: typeparams,
			Fields:     fields,
		},
	}
	return ret
}
