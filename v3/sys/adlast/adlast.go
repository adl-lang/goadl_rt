// Code generated by goadlc v2 - DO NOT EDIT.
package adlast

import (
	"fmt"
	"github.com/adl-lang/goadl_rt/v3/sys/types"
)

type Annotations = types.Map[ScopedName, any]

type Decl struct {
	Name        Ident
	Version     types.Maybe[uint32]
	Type_       DeclType
	Annotations Annotations
}

func New_Decl(
	name Ident,
	version types.Maybe[uint32],
	type_ DeclType,
	annotations Annotations,
) Decl {
	return Decl{
		Name:        name,
		Version:     version,
		Type_:       type_,
		Annotations: annotations,
	}
}

func Make_Decl(
	name Ident,
	version types.Maybe[uint32],
	type_ DeclType,
	annotations Annotations,
) Decl {
	ret := Decl{
		Name:        name,
		Version:     version,
		Type_:       type_,
		Annotations: annotations,
	}
	return ret
}

type DeclType struct {
	Branch DeclTypeBranch
}

type DeclTypeBranch interface {
	isDeclTypeBranch()
}

func (*DeclType) MakeNewBranch(key string) (any, error) {
	switch key {
	case "struct_":
		return DeclType_Struct_{}, nil
	case "union_":
		return DeclType_Union_{}, nil
	case "type_":
		return DeclType_Type_{}, nil
	case "newtype_":
		return DeclType_Newtype_{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type DeclType_Struct_ struct {
	V Struct `branch:"struct_"`
}
type DeclType_Union_ struct {
	V Union `branch:"union_"`
}
type DeclType_Type_ struct {
	V TypeDef `branch:"type_"`
}
type DeclType_Newtype_ struct {
	V NewType `branch:"newtype_"`
}

func (DeclType_Struct_) isDeclTypeBranch() {}

func (DeclType_Union_) isDeclTypeBranch() {}

func (DeclType_Type_) isDeclTypeBranch() {}

func (DeclType_Newtype_) isDeclTypeBranch() {}

func Make_DeclType_struct_(v Struct) DeclType {
	return DeclType{
		DeclType_Struct_{v},
	}
}

func Make_DeclType_union_(v Union) DeclType {
	return DeclType{
		DeclType_Union_{v},
	}
}

func Make_DeclType_type_(v TypeDef) DeclType {
	return DeclType{
		DeclType_Type_{v},
	}
}

func Make_DeclType_newtype_(v NewType) DeclType {
	return DeclType{
		DeclType_Newtype_{v},
	}
}

func Handle_DeclType[T any](
	_in DeclTypeBranch,
	struct_ func(struct_ Struct) T,
	union_ func(union_ Union) T,
	type_ func(type_ TypeDef) T,
	newtype_ func(newtype_ NewType) T,
	_default func() T,
) T {
	switch _b := _in.(type) {
	case DeclType_Struct_:
		if struct_ != nil {
			return struct_(_b.V)
		}
	case DeclType_Union_:
		if union_ != nil {
			return union_(_b.V)
		}
	case DeclType_Type_:
		if type_ != nil {
			return type_(_b.V)
		}
	case DeclType_Newtype_:
		if newtype_ != nil {
			return newtype_(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("code gen error unhandled branch in : DeclType")
}

func HandleWithErr_DeclType[T any](
	_in DeclTypeBranch,
	struct_ func(struct_ Struct) (T, error),
	union_ func(union_ Union) (T, error),
	type_ func(type_ TypeDef) (T, error),
	newtype_ func(newtype_ NewType) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.(type) {
	case DeclType_Struct_:
		if struct_ != nil {
			return struct_(_b.V)
		}
	case DeclType_Union_:
		if union_ != nil {
			return union_(_b.V)
		}
	case DeclType_Type_:
		if type_ != nil {
			return type_(_b.V)
		}
	case DeclType_Newtype_:
		if newtype_ != nil {
			return newtype_(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("code gen error unhandled branch in : DeclType")
}

type DeclVersions = []Decl

type Field struct {
	Name           Ident
	SerializedName Ident
	TypeExpr       TypeExpr
	Default        types.Maybe[any]
	Annotations    Annotations
}

func New_Field(
	name Ident,
	serializedname Ident,
	typeexpr TypeExpr,
	default_ types.Maybe[any],
	annotations Annotations,
) Field {
	return Field{
		Name:           name,
		SerializedName: serializedname,
		TypeExpr:       typeexpr,
		Default:        default_,
		Annotations:    annotations,
	}
}

func Make_Field(
	name Ident,
	serializedname Ident,
	typeexpr TypeExpr,
	default_ types.Maybe[any],
	annotations Annotations,
) Field {
	ret := Field{
		Name:           name,
		SerializedName: serializedname,
		TypeExpr:       typeexpr,
		Default:        default_,
		Annotations:    annotations,
	}
	return ret
}

type Ident = string

type Import struct {
	Branch ImportBranch
}

type ImportBranch interface {
	isImportBranch()
}

func (*Import) MakeNewBranch(key string) (any, error) {
	switch key {
	case "moduleName":
		return Import_ModuleName{}, nil
	case "scopedName":
		return Import_ScopedName{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type Import_ModuleName struct {
	V ModuleName `branch:"moduleName"`
}
type Import_ScopedName struct {
	V ScopedName `branch:"scopedName"`
}

func (Import_ModuleName) isImportBranch() {}

func (Import_ScopedName) isImportBranch() {}

func Make_Import_moduleName(v ModuleName) Import {
	return Import{
		Import_ModuleName{v},
	}
}

func Make_Import_scopedName(v ScopedName) Import {
	return Import{
		Import_ScopedName{v},
	}
}

func Handle_Import[T any](
	_in ImportBranch,
	moduleName func(moduleName ModuleName) T,
	scopedName func(scopedName ScopedName) T,
	_default func() T,
) T {
	switch _b := _in.(type) {
	case Import_ModuleName:
		if moduleName != nil {
			return moduleName(_b.V)
		}
	case Import_ScopedName:
		if scopedName != nil {
			return scopedName(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("code gen error unhandled branch in : Import")
}

func HandleWithErr_Import[T any](
	_in ImportBranch,
	moduleName func(moduleName ModuleName) (T, error),
	scopedName func(scopedName ScopedName) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.(type) {
	case Import_ModuleName:
		if moduleName != nil {
			return moduleName(_b.V)
		}
	case Import_ScopedName:
		if scopedName != nil {
			return scopedName(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("code gen error unhandled branch in : Import")
}

type Module struct {
	Name        ModuleName
	Imports     []Import
	Decls       map[string]Decl
	Annotations Annotations
}

func New_Module(
	name ModuleName,
	imports []Import,
	decls map[string]Decl,
	annotations Annotations,
) Module {
	return Module{
		Name:        name,
		Imports:     imports,
		Decls:       decls,
		Annotations: annotations,
	}
}

func Make_Module(
	name ModuleName,
	imports []Import,
	decls map[string]Decl,
	annotations Annotations,
) Module {
	ret := Module{
		Name:        name,
		Imports:     imports,
		Decls:       decls,
		Annotations: annotations,
	}
	return ret
}

type ModuleName = string

type NewType struct {
	TypeParams []Ident
	TypeExpr   TypeExpr
	Default    types.Maybe[any]
}

func New_NewType(
	typeparams []Ident,
	typeexpr TypeExpr,
	default_ types.Maybe[any],
) NewType {
	return NewType{
		TypeParams: typeparams,
		TypeExpr:   typeexpr,
		Default:    default_,
	}
}

func Make_NewType(
	typeparams []Ident,
	typeexpr TypeExpr,
	default_ types.Maybe[any],
) NewType {
	ret := NewType{
		TypeParams: typeparams,
		TypeExpr:   typeexpr,
		Default:    default_,
	}
	return ret
}

type ScopedDecl struct {
	ModuleName ModuleName
	Decl       Decl
}

func New_ScopedDecl(
	modulename ModuleName,
	decl Decl,
) ScopedDecl {
	return ScopedDecl{
		ModuleName: modulename,
		Decl:       decl,
	}
}

func Make_ScopedDecl(
	modulename ModuleName,
	decl Decl,
) ScopedDecl {
	ret := ScopedDecl{
		ModuleName: modulename,
		Decl:       decl,
	}
	return ret
}

type ScopedName struct {
	ModuleName ModuleName
	Name       Ident
}

func New_ScopedName(
	modulename ModuleName,
	name Ident,
) ScopedName {
	return ScopedName{
		ModuleName: modulename,
		Name:       name,
	}
}

func Make_ScopedName(
	modulename ModuleName,
	name Ident,
) ScopedName {
	ret := ScopedName{
		ModuleName: modulename,
		Name:       name,
	}
	return ret
}

type Struct struct {
	TypeParams []Ident
	Fields     []Field
}

func New_Struct(
	typeparams []Ident,
	fields []Field,
) Struct {
	return Struct{
		TypeParams: typeparams,
		Fields:     fields,
	}
}

func Make_Struct(
	typeparams []Ident,
	fields []Field,
) Struct {
	ret := Struct{
		TypeParams: typeparams,
		Fields:     fields,
	}
	return ret
}

type TypeDef struct {
	TypeParams []Ident
	TypeExpr   TypeExpr
}

func New_TypeDef(
	typeparams []Ident,
	typeexpr TypeExpr,
) TypeDef {
	return TypeDef{
		TypeParams: typeparams,
		TypeExpr:   typeexpr,
	}
}

func Make_TypeDef(
	typeparams []Ident,
	typeexpr TypeExpr,
) TypeDef {
	ret := TypeDef{
		TypeParams: typeparams,
		TypeExpr:   typeexpr,
	}
	return ret
}

type TypeExpr struct {
	TypeRef    TypeRef
	Parameters []TypeExpr
}

func New_TypeExpr(
	typeref TypeRef,
	parameters []TypeExpr,
) TypeExpr {
	return TypeExpr{
		TypeRef:    typeref,
		Parameters: parameters,
	}
}

func Make_TypeExpr(
	typeref TypeRef,
	parameters []TypeExpr,
) TypeExpr {
	ret := TypeExpr{
		TypeRef:    typeref,
		Parameters: parameters,
	}
	return ret
}

type TypeRef struct {
	Branch TypeRefBranch
}

type TypeRefBranch interface {
	isTypeRefBranch()
}

func (*TypeRef) MakeNewBranch(key string) (any, error) {
	switch key {
	case "primitive":
		return TypeRef_Primitive{}, nil
	case "typeParam":
		return TypeRef_TypeParam{}, nil
	case "reference":
		return TypeRef_Reference{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type TypeRef_Primitive struct {
	V Ident `branch:"primitive"`
}
type TypeRef_TypeParam struct {
	V Ident `branch:"typeParam"`
}
type TypeRef_Reference struct {
	V ScopedName `branch:"reference"`
}

func (TypeRef_Primitive) isTypeRefBranch() {}

func (TypeRef_TypeParam) isTypeRefBranch() {}

func (TypeRef_Reference) isTypeRefBranch() {}

func Make_TypeRef_primitive(v Ident) TypeRef {
	return TypeRef{
		TypeRef_Primitive{v},
	}
}

func Make_TypeRef_typeParam(v Ident) TypeRef {
	return TypeRef{
		TypeRef_TypeParam{v},
	}
}

func Make_TypeRef_reference(v ScopedName) TypeRef {
	return TypeRef{
		TypeRef_Reference{v},
	}
}

func Handle_TypeRef[T any](
	_in TypeRefBranch,
	primitive func(primitive Ident) T,
	typeParam func(typeParam Ident) T,
	reference func(reference ScopedName) T,
	_default func() T,
) T {
	switch _b := _in.(type) {
	case TypeRef_Primitive:
		if primitive != nil {
			return primitive(_b.V)
		}
	case TypeRef_TypeParam:
		if typeParam != nil {
			return typeParam(_b.V)
		}
	case TypeRef_Reference:
		if reference != nil {
			return reference(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("code gen error unhandled branch in : TypeRef")
}

func HandleWithErr_TypeRef[T any](
	_in TypeRefBranch,
	primitive func(primitive Ident) (T, error),
	typeParam func(typeParam Ident) (T, error),
	reference func(reference ScopedName) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.(type) {
	case TypeRef_Primitive:
		if primitive != nil {
			return primitive(_b.V)
		}
	case TypeRef_TypeParam:
		if typeParam != nil {
			return typeParam(_b.V)
		}
	case TypeRef_Reference:
		if reference != nil {
			return reference(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("code gen error unhandled branch in : TypeRef")
}

type Union struct {
	TypeParams []Ident
	Fields     []Field
}

func New_Union(
	typeparams []Ident,
	fields []Field,
) Union {
	return Union{
		TypeParams: typeparams,
		Fields:     fields,
	}
}

func Make_Union(
	typeparams []Ident,
	fields []Field,
) Union {
	ret := Union{
		TypeParams: typeparams,
		Fields:     fields,
	}
	return ret
}
